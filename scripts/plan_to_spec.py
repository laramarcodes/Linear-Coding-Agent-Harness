#!/usr/bin/env python3
"""
plan_to_spec.py - Convert build-anything plan files to app_spec.txt format

This script converts plan files generated by the build-anything skill
(~/.claude/plans/*.md) into the app_spec.txt format used by the harness.

Usage:
    python3 scripts/plan_to_spec.py ~/.claude/plans/my-app.md -o my_app_spec.txt
    python3 scripts/plan_to_spec.py ~/.claude/plans/my-app.md  # outputs to stdout
"""

import argparse
import re
import sys
from pathlib import Path


def extract_section(content: str, header: str) -> str:
    """Extract content under a markdown header."""
    # Match ## Header or ### Header
    pattern = rf"^##+ {re.escape(header)}\s*\n(.*?)(?=^##|\Z)"
    match = re.search(pattern, content, re.MULTILINE | re.DOTALL)
    if match:
        return match.group(1).strip()
    return ""


def extract_value(content: str, key: str) -> str:
    """Extract a value from **Key**: value format."""
    pattern = rf"\*\*{re.escape(key)}\*\*:\s*(.+?)(?:\n|$)"
    match = re.search(pattern, content)
    if match:
        return match.group(1).strip()
    return ""


def parse_table(content: str) -> list[dict]:
    """Parse a markdown table into list of dicts."""
    lines = content.strip().split("\n")
    if len(lines) < 3:
        return []

    # Get headers from first line
    headers = [h.strip() for h in lines[0].split("|") if h.strip()]

    # Skip separator line, parse data rows
    rows = []
    for line in lines[2:]:
        if not line.strip() or line.strip().startswith("|--"):
            continue
        values = [v.strip() for v in line.split("|") if v.strip()]
        if len(values) >= len(headers):
            rows.append(dict(zip(headers, values)))

    return rows


def convert_plan_to_spec(plan_content: str) -> str:
    """Convert a build-anything plan to app_spec.txt format."""

    # Extract sections
    overview = extract_section(plan_content, "App Overview")
    design = extract_section(plan_content, "Design Direction")
    schema = extract_section(plan_content, "Convex Schema")
    routes = extract_section(plan_content, "Route Structure")
    components = extract_section(plan_content, "Components")
    features = extract_section(plan_content, "Features by Priority")
    implementation = extract_section(plan_content, "Implementation Order")

    # Extract specific values
    project_name = extract_value(overview, "Type") or "My Application"
    description = extract_value(overview, "Description") or ""
    problem = extract_value(overview, "Problem Solved") or ""
    users = extract_value(overview, "Target Users") or ""

    aesthetic = extract_value(design, "Aesthetic") or ""
    display_font = extract_value(design, "Display Font") or ""
    body_font = extract_value(design, "Body Font") or ""
    primary_color = extract_value(design, "Primary Color") or ""
    accent_color = extract_value(design, "Accent Color") or ""

    # Try to extract project name from markdown title
    title_match = re.search(r"^# Plan: (.+)$", plan_content, re.MULTILINE)
    if title_match:
        project_name = title_match.group(1).strip()

    # Build the spec
    spec = f'''<project_specification>
  <project_name>{project_name}</project_name>

  <overview>
    {description}

    Problem: {problem}
    Target Users: {users}
  </overview>

  <technology_stack>
    <frontend>
      <framework>Next.js 14+ with App Router</framework>
      <styling>TailwindCSS with shadcn/ui components</styling>
      <state_management>React hooks and Convex real-time subscriptions</state_management>
      <routing>Next.js App Router</routing>
      <port>Only launch on port 3000</port>
    </frontend>
    <backend>
      <runtime>Convex (serverless TypeScript)</runtime>
      <database>Convex (built-in real-time database)</database>
      <authentication>Clerk</authentication>
    </backend>
    <communication>
      <api>Convex functions (queries, mutations, actions)</api>
      <realtime>Convex real-time subscriptions</realtime>
    </communication>
  </technology_stack>

  <prerequisites>
    <environment_setup>
      - Node.js 18+ installed
      - Clerk account with API keys
      - Convex account (will prompt during setup)
      - Run init_project.py to scaffold
    </environment_setup>
  </prerequisites>

  <core_features>
    {features if features else "<!-- Add your features here -->"}
  </core_features>

  <database_schema>
    <tables>
      {schema if schema else "<!-- Add your schema here -->"}
    </tables>
  </database_schema>

  <api_endpoints_summary>
    <!-- Convex uses functions instead of REST endpoints -->
    {routes if routes else "<!-- Add your routes here -->"}
  </api_endpoints_summary>

  <ui_layout>
    <main_structure>
      <!-- Derived from route structure -->
    </main_structure>

    <components>
      {components if components else "<!-- Add your components here -->"}
    </components>
  </ui_layout>

  <design_system>
    <color_palette>
      - Primary: {primary_color or "Define your primary color"}
      - Accent: {accent_color or "Define your accent color"}
    </color_palette>

    <typography>
      - Display Font: {display_font or "Define your display font"}
      - Body Font: {body_font or "Define your body font"}
    </typography>

    <aesthetic_direction>
      {aesthetic or "Define your aesthetic direction"}
    </aesthetic_direction>
  </design_system>

  <implementation_steps>
    {implementation if implementation else '''
    <step number="1">
      <title>Project Scaffolding</title>
      <tasks>
        - Run init_project.py to create Next.js + Convex + Clerk project
        - Configure environment variables
      </tasks>
    </step>

    <step number="2">
      <title>Schema Implementation</title>
      <tasks>
        - Implement Convex schema
        - Create base queries and mutations
        - Set up Clerk webhook
      </tasks>
    </step>

    <step number="3">
      <title>Core UI</title>
      <tasks>
        - Build layout components
        - Implement navigation
        - Create main views
      </tasks>
    </step>
    '''}
  </implementation_steps>

  <success_criteria>
    <functionality>
      - All CRUD operations work correctly
      - Authentication flow is secure and complete
      - Real-time updates work across clients
      - Data persists correctly
    </functionality>

    <user_experience>
      - Interface matches the {aesthetic or "chosen"} aesthetic direction
      - Responsive on mobile, tablet, and desktop
      - Loading states provide feedback
      - Error messages are helpful
    </user_experience>

    <technical_quality>
      - TypeScript compiles without errors
      - All Convex functions have return validators
      - No N+1 query patterns
      - Proper error handling throughout
    </technical_quality>
  </success_criteria>
</project_specification>
'''

    return spec


def main():
    parser = argparse.ArgumentParser(
        description="Convert build-anything plan files to app_spec.txt format",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert a plan file
  python3 scripts/plan_to_spec.py ~/.claude/plans/my-app.md -o my_app_spec.txt

  # Output to stdout
  python3 scripts/plan_to_spec.py ~/.claude/plans/my-app.md

  # List available plan files
  ls ~/.claude/plans/
        """
    )

    parser.add_argument(
        "plan_file",
        type=Path,
        help="Path to the plan file (e.g., ~/.claude/plans/my-app.md)"
    )

    parser.add_argument(
        "-o", "--output",
        type=Path,
        default=None,
        help="Output file path (default: stdout)"
    )

    args = parser.parse_args()

    # Expand ~ in path
    plan_path = args.plan_file.expanduser()

    if not plan_path.exists():
        print(f"Error: Plan file not found: {plan_path}", file=sys.stderr)
        print(f"\nAvailable plan files in ~/.claude/plans/:", file=sys.stderr)
        plans_dir = Path("~/.claude/plans").expanduser()
        if plans_dir.exists():
            for f in plans_dir.glob("*.md"):
                print(f"  {f.name}", file=sys.stderr)
        else:
            print("  (directory does not exist)", file=sys.stderr)
        sys.exit(1)

    # Read and convert
    plan_content = plan_path.read_text()
    spec_content = convert_plan_to_spec(plan_content)

    # Output
    if args.output:
        output_path = args.output.expanduser()
        output_path.write_text(spec_content)
        print(f"Spec written to: {output_path}")
    else:
        print(spec_content)


if __name__ == "__main__":
    main()
